# Question 1
How did you structure your transmit implementation? In particular, what do you do if the transmit ring is full?

My transmit implementation drops the packet if the ring is full. It alerts the user to this fact using a return from the driver (and syscall). The user process using the system interface is responsible for checking whether their packet succeeded completely if they care.
The return status is set up so as not to disturb users who don't care if a packet is dropped. A positive value (length of the packet) means complete success, a zero means a dropped packet (still somewhat a success), and a negative value indicates utter disaster.

# Question 2
How did you structure your receive implementation? In particular, what do you do if the receive queue is empty and a user environment requests the next incoming packet?

My receive implementation returns a zero if the queue is empty (there are no packets available for processes to consume). A positive vlue indicates that data was written and how many bytes, 0 indicates that no packet is available, and a negative value indicates a problem. It is up for the user to spin if they require a packet to continue. This could be implemented as a blocking library os helper method like ipc_send but I have not implemented one yet.

# Question 3
What does the web page served by JOS's web server say?

This file came from JOS.
Cheesy web page!

# Question 4
How long approximately did it take you to do this lab?

I don't know anymore. So long. >16 hours?

# Challenge
Read EEPROM
TODO writeup
