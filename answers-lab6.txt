# Question 1
How did you structure your transmit implementation? In particular, what do you do if the transmit ring is full?

My transmit implementation drops the packet if the ring is full. It alerts the user to this fact using a return from the driver (and syscall). The user process using the system interface is responsible for checking whether their packet succeeded completely if they care.
The return status is set up so as not to disturb users who don't care if a packet is dropped. A positive value (length of the packet) means complete success, a zero means a dropped packet (still somewhat a success), and a negative value indicates utter disaster.

# Question 2
How did you structure your receive implementation? In particular, what do you do if the receive queue is empty and a user environment requests the next incoming packet?

My receive implementation returns a zero if the queue is empty (there are no packets available for processes to consume). A positive vlue indicates that data was written and how many bytes, 0 indicates that no packet is available, and a negative value indicates a problem. It is up for the user to spin if they require a packet to continue. This could be implemented as a blocking library os helper method like ipc_send but I have not implemented one yet.

# Question 3
What does the web page served by JOS's web server say?

This file came from JOS.
Cheesy web page!

# Question 4
How long approximately did it take you to do this lab?

I don't know anymore. So long. >16 hours?

# Challenge
Challenge! Read about the EEPROM in the developer's manual and write the code to load the E1000's MAC address out of the EEPROM. Currently, QEMU's default MAC address is hard-coded into both your receive initialization and lwIP. Fix your initialization to use the MAC address you read from the EEPROM, add a system call to pass the MAC address to lwIP, and modify lwIP to the MAC address read from the card. Test your change by configuring QEMU to use a different MAC address.

During the initialization of the e1000 the driver reads the MAC address from EEPROM and stores it in the drivers memory. It sets the e1000 filter to listen only for that MAC.
I added the system call `sys_net_get_mac` so that a user process can get the MAC current address. Because MAC addresses are a bit tricky to handle due to the weird byte order, sys_net_get_mac fills in a `struct MAC` which has a bytes array to try to make it the least ambiguous data format for the user to consume.
The hardcoded MAC in jif.c and in testinput.c has been replaced with a call to sys_net_get_mac.
To try it out, change the line in GNUmakefile that looks like this
    QEMUOPTS += -net user -net nic,macaddr=52:54:00:12:34:56,model=e1000 -redir tcp:$(PORT7)::7 \
And look for the output like
    e1000 read MAC as 52:54:00:12:34:56
